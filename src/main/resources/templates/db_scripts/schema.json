{
  "tables": [
    {
      "tableName": "note_data",
      "fromModuleVersion": 0.2,
      "withMetadata": true,
      "generateId": true,
      "populateJsonWithId": true,
      "likeIndex": [
        {
          "fieldName": "title",
          "tOps": "ADD",
          "caseSensitive": false
        }
      ]
    },
    {
      "tableName": "note_type",
      "generateId": true,
      "fromModuleVersion": 1.0,
      "withMetadata": true,
      "populateJsonWithId": true,
      "uniqueIndex" : [
        {
          "fieldName" : "name",
          "tOps" : "ADD"
        }
      ],
      "likeIndex": [
        {
          "fieldName": "name",
          "tOps": "ADD",
          "caseSensitive": false
        }
      ]
    }
  ],
  "scripts": [
    {
      "run": "after",
      "snippet": "ALTER TABLE note_data ADD COLUMN temporary_type_id UUID REFERENCES note_type (id);CREATE OR REPLACE FUNCTION update_type_id()RETURNS TRIGGER AS $$BEGIN  NEW.temporary_type_id = NEW.jsonb->>'typeId';  RETURN NEW;END;$$ language 'plpgsql'; CREATE TRIGGER update_type_id  BEFORE INSERT OR UPDATE ON note_data  FOR EACH ROW EXECUTE PROCEDURE update_type_id();",
      "fromModuleVersion": "1.0"
    },
    {
      "run": "after",
      "snippet": "CREATE OR REPLACE VIEW note_view AS SELECT note_data.id, jsonb_build_object( 'id', note_data.jsonb->>'id',  'title', note_data.jsonb->>'title',  'content', note_data.jsonb->>'content',  'creator', note_data.jsonb->'creator',  'updater', note_data.jsonb->'updater',  'links', note_data.jsonb->'links',  'linkDomains',  (SELECT array_agg(DISTINCT domain) FROM jsonb_to_recordset(note_data.jsonb->'links') AS x(domain text)),  'linkTypes',  (SELECT array_agg(DISTINCT type) FROM jsonb_to_recordset(note_data.jsonb->'links') AS x(type text)),  'linkIds',  (SELECT array_agg(DISTINCT id) FROM jsonb_to_recordset(note_data.jsonb->'links') AS x(id text)), 'metadata', note_data.jsonb->'metadata',  'typeId', note_type.jsonb->'id', 'type', note_type.jsonb->'name') AS jsonb FROM note_data LEFT JOIN note_type ON note_data.jsonb->>'typeId' = note_type.jsonb->>'id';",
      "fromModuleVersion": "1.0"
    },
    {
      "run": "after",
      "snippet": "CREATE OR REPLACE FUNCTION set_note_data_md_json()    RETURNS TRIGGER AS $$ DECLARE   createdDate timestamp WITH TIME ZONE;   createdBy text ;   updatedDate timestamp WITH TIME ZONE;   updatedBy text ;   injectedId text;   injectedJsonb text; BEGIN   createdBy = NEW.created_by;   createdDate = NEW.creation_date;   updatedDate = NEW.jsonb->'metadata'->>'updatedDate';   updatedBy = NEW.jsonb->'metadata'->>'updatedByUserId';   injectedJsonb = NEW.jsonb->'metadata';   if createdBy ISNULL then     createdBy = 'undefined'; end if;   if updatedBy ISNULL then     updatedBy = 'undefined'; end if;   if createdDate IS NOT NULL     then     injectedId = '{\"createdDate\":\"'||to_char(createdDate,'YYYY-MM-DD\"T\"HH24:MI:SS.MS')||'\" , \"createdByUserId\":\"'||createdBy||'\", \"updatedDate\":\"'||to_char(updatedDate,'YYYY-MM-DD\"T\"HH24:MI:SS.MSOF')||'\" , \"updatedByUserId\":\"'||updatedBy||'\"}';     NEW.jsonb = jsonb_set(NEW.jsonb, '{metadata}' , injectedJsonb::jsonb || injectedId::jsonb , false);   else     NEW.jsonb = NEW.jsonb;   end if; RETURN NEW; END;$$ language 'plpgsql'; DROP TRIGGER IF EXISTS set_note_data_md_json_trigger ON note_data CASCADE; CREATE TRIGGER set_note_data_md_json_trigger BEFORE UPDATE ON note_data   FOR EACH ROW EXECUTE PROCEDURE set_note_data_md_json();",
      "fromModuleVersion": "1.0"
    },
    {
      "run": "after",
      "snippet": "CREATE OR REPLACE FUNCTION set_note_type_md_json()    RETURNS trigger AS $$  DECLARE    createdDate timestamp WITH TIME ZONE;    createdBy text ;    updatedDate timestamp WITH TIME ZONE;    updatedBy text ;    injectedId text;    injectedJsonb text;  BEGIN    createdBy = NEW.created_by;    createdDate = NEW.creation_date;   updatedDate = NEW.jsonb->'metadata'->>'updatedDate';   updatedBy = NEW.jsonb->'metadata'->>'updatedByUserId';   injectedJsonb = NEW.jsonb->'metadata';  if createdBy ISNULL then     createdBy = 'undefined';   end if;   if updatedBy ISNULL then     updatedBy = 'undefined';   end if;  if createdDate IS NOT NULL     then injectedId = '{\"createdDate\":\"'||to_char(createdDate,'YYYY-MM-DD\"T\"HH24:MI:SS.MS')||'\" , \"createdByUserId\":\"'||createdBy||'\", \"updatedDate\":\"'||to_char(updatedDate,'YYYY-MM-DD\"T\"HH24:MI:SS.MSOF')||'\" , \"updatedByUserId\":\"'||updatedBy||'\"}';     NEW.jsonb = jsonb_set(NEW.jsonb, '{metadata}' ,  injectedJsonb::jsonb || injectedId::jsonb , false);   else     NEW.jsonb = NEW.jsonb;   end if; RETURN NEW;  END; $$ language 'plpgsql'; DROP TRIGGER IF EXISTS set_note_type_md_json_trigger ON note_type CASCADE; CREATE TRIGGER set_note_type_md_json_trigger BEFORE UPDATE ON note_type   FOR EACH ROW EXECUTE PROCEDURE set_note_type_md_json();"
    },
    {
      "run": "after",
      "snippet": "CREATE OR REPLACE VIEW note_type_view select note_type.id, jsonb_build_object('id', note_type.jsonb ->> 'id'::text, 'name', note_type.jsonb ->> 'name'::text, 'usage',json_build_object('noteTotal', count(note_data.jsonb ->> 'id'::text)), 'metadata', note_type.jsonb -> 'metadata'::text) AS jsonb FROM diku_mod_notes.note_type LEFT JOIN diku_mod_notes.note_data ON (note_data.jsonb ->> 'typeId'::text) = (note_type.id) GROUP BY note_type.id;",
      "fromModuleVersion": "1.0"
    }
  ]
}
