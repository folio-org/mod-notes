-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 
BEGIN;
CREATE OR REPLACE FUNCTION f_unaccent(
	text)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE 
AS $BODY$
SELECT $1
$BODY$;

CREATE FUNCTION set_id_in_jsonb()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
  NEW.jsonb = jsonb_set(NEW.jsonb, '{id}', to_jsonb(NEW.id));
  RETURN NEW;
END;
$BODY$;

CREATE FUNCTION set_note_data_md_json()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    createdDate timestamp WITH TIME ZONE;
    createdBy text ;
    updatedDate timestamp WITH TIME ZONE;
    updatedBy text ;
    injectedMetadata text;
    createdByUsername text;
    updatedByUsername text;
 BEGIN
   createdBy = OLD.jsonb->'metadata'->>'createdByUserId';
   createdDate = OLD.jsonb->'metadata'->>'createdDate';
   createdByUsername = OLD.jsonb->'metadata'->>'createdByUsername';
   updatedBy = NEW.jsonb->'metadata'->>'updatedByUserId';
   updatedDate = NEW.jsonb->'metadata'->>'updatedDate';
   updatedByUsername = NEW.jsonb->'metadata'->>'updatedByUsername';
   if createdBy ISNULL then     createdBy = 'undefined';   end if;
   if updatedBy ISNULL then     updatedBy = 'undefined';   end if;
   if createdByUsername ISNULL then     createdByUsername = 'undefined';   end if;
   if updatedByUsername ISNULL then     updatedByUsername = 'undefined';   end if;
   if createdDate IS NOT NULL
       then injectedMetadata = '{"createdDate":"'||to_char(createdDate,'YYYY-MM-DD"T"HH24:MI:SS.MS')||'" , "createdByUserId":"'||createdBy||'" , "createdByUsername":"'||createdByUsername||'", "updatedDate":"'||to_char(updatedDate,'YYYY-MM-DD"T"HH24:MI:SS.MSOF')||'" , "updatedByUserId":"'||updatedBy||'" , "updatedByUsername":"'|| updatedByUsername||'"}';
       NEW.jsonb = jsonb_set(NEW.jsonb, '{metadata}' ,  injectedMetadata::jsonb , false);
   else
     NEW.jsonb = NEW.jsonb;
   end if;
 RETURN NEW;
 END;
$BODY$;

CREATE FUNCTION update_search_content()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
  NEW.search_content = f_unaccent(coalesce(NEW.jsonb->>'title','') || ' '
  || regexp_replace(
      regexp_replace(
          coalesce(NEW.jsonb->>'content',''),
          E'<[^>]+>', '', 'gi'
       ),
      '\n+', ' ', 'gi'
    ));
  RETURN NEW;
END;
$BODY$;

CREATE FUNCTION update_type_id()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
  NEW.temporary_type_id = NEW.jsonb->>'typeId';
  RETURN NEW;
END;
$BODY$;

CREATE FUNCTION set_note_type_md_json()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    createdDate timestamp WITH TIME ZONE;
    createdBy text ;
    updatedDate timestamp WITH TIME ZONE;
    updatedBy text ;
    injectedMetadata text;
    createdByUsername text;
    updatedByUsername text;
  BEGIN
    createdBy = OLD.jsonb->'metadata'->>'createdByUserId';
    createdDate = OLD.jsonb->'metadata'->>'createdDate';
    createdByUsername = OLD.jsonb->'metadata'->>'createdByUsername';
    updatedBy = NEW.jsonb->'metadata'->>'updatedByUserId';
    updatedDate = NEW.jsonb->'metadata'->>'updatedDate';
    updatedByUsername = NEW.jsonb->'metadata'->>'updatedByUsername';
    if createdBy ISNULL then     createdBy = 'undefined';   end if;
    if updatedBy ISNULL then     updatedBy = 'undefined';   end if;
    if createdByUsername ISNULL then     createdByUsername = 'undefined';   end if;
    if updatedByUsername ISNULL then     updatedByUsername = 'undefined';   end if;
    if createdDate IS NOT NULL
        then injectedMetadata = '{"createdDate":"'||to_char(createdDate,'YYYY-MM-DD"T"HH24:MI:SS.MS')||'" , "createdByUserId":"'||createdBy||'" , "createdByUsername":"'||createdByUsername||'", "updatedDate":"'||to_char(updatedDate,'YYYY-MM-DD"T"HH24:MI:SS.MSOF')||'" , "updatedByUserId":"'||updatedBy||'" , "updatedByUsername":"'|| updatedByUsername||'"}';
        NEW.jsonb = jsonb_set(NEW.jsonb, '{metadata}' ,  injectedMetadata::jsonb , false);
    else
      NEW.jsonb = NEW.jsonb;
    end if;
 RETURN NEW;
 END;
$BODY$;

CREATE OR REPLACE FUNCTION concat_array_object(
	jsonb_array jsonb)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT string_agg(value::text, ' ') FROM jsonb_array_elements_text($1);
$BODY$;

CREATE OR REPLACE FUNCTION concat_array_object_values(
	jsonb_array jsonb,
	field text)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT string_agg(value->>$2, ' ') FROM jsonb_array_elements($1);
$BODY$;

CREATE OR REPLACE FUNCTION concat_array_object_values(
	jsonb_array jsonb,
	field text,
	filterkey text,
	filtervalue text)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT string_agg(value->>$2, ' ') FROM jsonb_array_elements($1) WHERE value->>$3 = $4;
$BODY$;

CREATE OR REPLACE FUNCTION concat_space_sql(
	VARIADIC text[])
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
select concat_ws(' ', VARIADIC $1);
$BODY$;

CREATE OR REPLACE FUNCTION count_estimate(
	query text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    STABLE STRICT PARALLEL UNSAFE
AS $BODY$
DECLARE
  count bigint;
  est_count bigint;
  q text;
BEGIN
  est_count = count_estimate_smart2(1000, 1000, query);
  IF est_count > 4*1000 THEN
    RETURN est_count;
  END IF;
  q = 'SELECT COUNT(*) FROM (' || query || ' LIMIT 1000) x';
  EXECUTE q INTO count;
  IF count < 1000 THEN
    RETURN count;
  END IF;
  IF est_count < 1000 THEN
    RETURN 1000;
  END IF;
  RETURN est_count;
END;
$BODY$;

CREATE OR REPLACE FUNCTION count_estimate_default(
	query text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    IMMUTABLE STRICT PARALLEL UNSAFE
AS $BODY$
DECLARE
  rows bigint;
  q text;
BEGIN
  q = 'SELECT COUNT(*) FROM (' || query || ' LIMIT 1000) x';
  EXECUTE q INTO rows;
  IF rows < 1000 THEN
    return rows;
  END IF;
  rows = count_estimate_smart2(1000, 1000, query);
  IF rows < 1000 THEN
    return 1000;
  END IF;
  RETURN rows;
END;
$BODY$;

CREATE OR REPLACE FUNCTION count_estimate_smart2(
	rows bigint,
	lim bigint,
	query text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE STRICT PARALLEL UNSAFE
AS $BODY$
DECLARE
  rec   record;
  cnt bigint;
BEGIN
  IF rows = lim THEN
      FOR rec IN EXECUTE 'EXPLAIN ' || query LOOP
        cnt := substring(rec."QUERY PLAN" FROM ' rows=([[:digit:]]+)');
        EXIT WHEN cnt IS NOT NULL;
      END LOOP;
      RETURN cnt;
  END IF;
  RETURN rows;
END;
$BODY$;

CREATE OR REPLACE FUNCTION first_array_object_value(
	jsonb_array jsonb,
	field text,
	filterkey text,
	filtervalue text)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT value->>$2 FROM jsonb_array_elements($1) WHERE value->>$3 = $4 LIMIT 1;
$BODY$;

CREATE OR REPLACE FUNCTION get_tsvector(
	text)
    RETURNS tsvector
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT to_tsvector('simple', translate($1, '&', ','));
$BODY$;

CREATE OR REPLACE FUNCTION next_uuid(
	uuid)
    RETURNS uuid
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
  uuid text;
  digit text;
BEGIN
  uuid = $1;
  FOR i IN REVERSE 36..1 LOOP
    digit := substring(uuid from i for 1);
    -- skip minus, version byte M and variant byte N
    CONTINUE WHEN digit = '-' OR i = 15 OR i = 20;
    CASE digit
      WHEN '0' THEN digit := '1';
      WHEN '1' THEN digit := '2';
      WHEN '2' THEN digit := '3';
      WHEN '3' THEN digit := '4';
      WHEN '4' THEN digit := '5';
      WHEN '5' THEN digit := '6';
      WHEN '6' THEN digit := '7';
      WHEN '7' THEN digit := '8';
      WHEN '8' THEN digit := '9';
      WHEN '9' THEN digit := 'a';
      WHEN 'a' THEN digit := 'b';
      WHEN 'b' THEN digit := 'c';
      WHEN 'c' THEN digit := 'd';
      WHEN 'd' THEN digit := 'e';
      WHEN 'e' THEN digit := 'f';
      WHEN 'f' THEN digit := '0';
      ELSE NULL;
    END CASE;
    uuid = overlay(uuid placing digit from i);
    EXIT WHEN digit <> '0';
  END LOOP;
  RETURN uuid;
END;
$BODY$;

CREATE OR REPLACE FUNCTION normalize_digits(
	text)
    RETURNS text
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT    translate((regexp_match($1, '^([0-9 \t-]*(?:\*[ \t]*)?)(.*)'))[1], E' \t-', '')
         || CASE WHEN (regexp_match($1, '^([0-9 \t-]*(?:\*[ \t]*)?)(.*)'))[1] = '' THEN ''
                 WHEN (regexp_match($1, '^([0-9 \t-]*(?:\*[ \t]*)?)(.*)'))[2] = '' THEN ''
                 ELSE ' '
            END
         || (regexp_match($1, '^([0-9 \t-]*(?:\*[ \t]*)?)(.*)'))[2];
$BODY$;

CREATE OR REPLACE FUNCTION rmb_internal_index(
	atable text,
	aname text,
	tops text,
	newdef text)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
  olddef text;
  namep CONSTANT text = concat(aname, '_p');
  prepareddef text;
BEGIN
  IF tops = 'DELETE' THEN
    -- use case insensitive %s, not case sensitive %I
    -- no SQL injection because the names are hard-coded in schema.json
    EXECUTE format('DROP INDEX IF EXISTS %s', aname);
    EXECUTE 'DELETE FROM rmb_internal_index WHERE name = $1' USING aname;
    RETURN;
  END IF;
  SELECT def INTO olddef      FROM rmb_internal_index WHERE name = aname;
  SELECT def INTO prepareddef FROM rmb_internal_index WHERE name = namep;
  prepareddef = replace(prepareddef, concat(' ', namep, ' ON '), concat(' ', aname, ' ON '));
  IF prepareddef = newdef THEN
    EXECUTE format('DROP INDEX IF EXISTS %s', aname);
    EXECUTE format('ALTER INDEX IF EXISTS %s RENAME TO %s', namep, aname);
    EXECUTE 'DELETE FROM rmb_internal_index WHERE name = $1' USING namep;
    EXECUTE 'INSERT INTO rmb_internal_analyze VALUES ($1)' USING atable;
  ELSIF olddef IS DISTINCT FROM newdef THEN
    EXECUTE format('DROP INDEX IF EXISTS %s', aname);
    EXECUTE newdef;
    EXECUTE 'INSERT INTO rmb_internal_analyze VALUES ($1)' USING atable;
  END IF;
  EXECUTE 'INSERT INTO rmb_internal_index VALUES ($1, $2, FALSE) ON CONFLICT (name) DO UPDATE SET def = EXCLUDED.def, remove = EXCLUDED.remove' USING aname, newdef;
END
$BODY$;

CREATE OR REPLACE FUNCTION tsquery_and(
	text)
    RETURNS tsquery
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT to_tsquery('simple', string_agg(CASE WHEN length(v) = 0 OR v = '*' THEN ''
                                              WHEN right(v, 1) = '*' THEN '''' || left(v, -1) || ''':*'
                                              ELSE '''' || v || '''' END,
                                         '&'))
  FROM (SELECT regexp_split_to_table(translate($1, '&''', ',,'), ' +')) AS x(v);
$BODY$;

CREATE OR REPLACE FUNCTION tsquery_or(
	text)
    RETURNS tsquery
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT replace(tsquery_and($1)::text, '&', '|')::tsquery;
$BODY$;

CREATE OR REPLACE FUNCTION tsquery_phrase(
	text)
    RETURNS tsquery
    LANGUAGE 'sql'
    COST 100
    IMMUTABLE STRICT PARALLEL SAFE
AS $BODY$
SELECT replace(tsquery_and($1)::text, '&', '<->')::tsquery;
$BODY$;

CREATE OR REPLACE FUNCTION upsert(
	text,
	uuid,
	anyelement)
    RETURNS uuid
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
  ret uuid;
BEGIN
  EXECUTE format('UPDATE %I SET jsonb=$3 WHERE id=$2 RETURNING id', $1)
          USING $1, $2, $3 INTO ret;
  IF ret IS NOT NULL THEN
    RETURN ret;
  END IF;
  EXECUTE format('INSERT INTO %I (id, jsonb) VALUES ($2, $3) RETURNING id', $1)
          USING $1, $2, $3 INTO STRICT ret;
  RETURN ret;
END;
$BODY$;

CREATE OR REPLACE FUNCTION uuid_larger(
	uuid,
	uuid)
    RETURNS uuid
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
  IF $1 IS NULL THEN
    RETURN $2;
  END IF;
  IF $2 IS NULL THEN
    RETURN $1;
  END IF;
  IF $1 > $2 THEN
    RETURN $1;
  ELSE
    RETURN $2;
  END IF;
END;
$BODY$;

CREATE OR REPLACE FUNCTION uuid_smaller(
	uuid,
	uuid)
    RETURNS uuid
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
  IF $1 IS NULL THEN
    RETURN $2;
  END IF;
  IF $2 IS NULL THEN
    RETURN $1;
  END IF;
  IF $1 < $2 THEN
    RETURN $1;
  ELSE
    RETURN $2;
  END IF;
END;
$BODY$;

CREATE SEQUENCE rmb_internal_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

CREATE TABLE note_type
(
    id uuid NOT NULL,
    jsonb jsonb NOT NULL,
    CONSTRAINT note_type_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

CREATE TABLE note_data
(
    id uuid NOT NULL,
    jsonb jsonb NOT NULL,
    temporary_type_id uuid,
    search_content text COLLATE pg_catalog."default",
    CONSTRAINT note_data_pkey PRIMARY KEY (id),
    CONSTRAINT note_data_temporary_type_id_fkey FOREIGN KEY (temporary_type_id)
        REFERENCES note_type (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

CREATE INDEX note_data_title_idx_like
    ON note_data USING btree
    (lower(f_unaccent(jsonb ->> 'title'::text)) COLLATE pg_catalog."default" text_pattern_ops ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX search_content_idx_gin
    ON note_data
    (search_content COLLATE pg_catalog."default")
    TABLESPACE pg_default;

CREATE TRIGGER set_id_in_jsonb
    BEFORE INSERT OR UPDATE 
    ON note_data
    FOR EACH ROW
    EXECUTE FUNCTION set_id_in_jsonb();

CREATE TRIGGER set_note_data_md_json_trigger
    BEFORE UPDATE 
    ON note_data
    FOR EACH ROW
    EXECUTE FUNCTION set_note_data_md_json();

CREATE TRIGGER update_search_content
    BEFORE INSERT OR UPDATE 
    ON note_data
    FOR EACH ROW
    EXECUTE FUNCTION update_search_content();

CREATE TRIGGER update_type_id
    BEFORE INSERT OR UPDATE 
    ON note_data
    FOR EACH ROW
    EXECUTE FUNCTION update_type_id();


CREATE INDEX note_type_name_idx_like
    ON note_type USING btree
    (lower(f_unaccent(jsonb ->> 'name'::text)) COLLATE pg_catalog."default" text_pattern_ops ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE UNIQUE INDEX note_type_name_idx_unique
    ON note_type USING btree
    (lower(f_unaccent(jsonb ->> 'name'::text)) COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

CREATE TRIGGER set_id_in_jsonb
    BEFORE INSERT OR UPDATE 
    ON note_type
    FOR EACH ROW
    EXECUTE FUNCTION set_id_in_jsonb();

CREATE TRIGGER set_note_type_md_json_trigger
    BEFORE UPDATE 
    ON note_type
    FOR EACH ROW
    EXECUTE FUNCTION set_note_type_md_json();
CREATE TABLE rmb_internal
(
    id integer NOT NULL DEFAULT nextval('rmb_internal_id_seq'::regclass),
    jsonb jsonb NOT NULL,
    CONSTRAINT rmb_internal_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

CREATE TABLE rmb_internal_analyze
(
    tablename text COLLATE pg_catalog."default"
)

TABLESPACE pg_default;

CREATE TABLE rmb_internal_index
(
    name text COLLATE pg_catalog."default" NOT NULL,
    def text COLLATE pg_catalog."default" NOT NULL,
    remove boolean NOT NULL,
    CONSTRAINT rmb_internal_index_pkey PRIMARY KEY (name)
)

TABLESPACE pg_default;

CREATE TABLE rmb_job
(
    id uuid NOT NULL,
    jsonb jsonb NOT NULL,
    CONSTRAINT rmb_job_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

CREATE OR REPLACE VIEW note_type_view
 AS
 SELECT note_type.id,
    jsonb_build_object('id', note_type.jsonb ->> 'id'::text, 'name', note_type.jsonb ->> 'name'::text, 'usage', json_build_object('noteTotal', count(note_data.jsonb ->> 'id'::text)), 'metadata', note_type.jsonb -> 'metadata'::text) AS jsonb
   FROM note_type
     LEFT JOIN note_data ON ((note_data.jsonb ->> 'typeId'::text)::uuid) = note_type.id
  GROUP BY note_type.id;

CREATE OR REPLACE VIEW note_view
 AS
 SELECT nd.id,
    nd.jsonb || jsonb_build_object('linkTypes', ( SELECT array_agg(DISTINCT x.type) AS array_agg
           FROM jsonb_to_recordset(nd.jsonb -> 'links'::text) x(type text)), 'linkIds', ( SELECT array_agg(DISTINCT x.id) AS array_agg
           FROM jsonb_to_recordset(nd.jsonb -> 'links'::text) x(id text)), 'type', nt.jsonb -> 'name'::text) AS jsonb
   FROM note_data nd
     LEFT JOIN note_type nt ON (nd.jsonb ->> 'typeId'::text) = (nt.jsonb ->> 'id'::text);

END;